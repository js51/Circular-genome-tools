
from sage.all_cmdline import *

####Saves a list of equivalence class representatives for a time reversible model with dihedral symmetry
##also calculates cardinality of each class 

N=4
K=SymmetricGroup(N)
Dlist=DihedralGroup(N)

##calculating the equivalence classes, saving reps as a text file and writing classreps and cardinalities to a list (this bit can be omitted for bigger N)
cards=[]
sdreps=open('genomes_S'+str(N)+'.txt','w')
Kset=Set(K)
i=0
while Kset.cardinality()>0:
	V=Set()
	T=Set()
	j=0
	while j<(2*N):
		k=0
		while k<(2*N):
			V=V.union(Set([K(Dlist[j])*Kset[0]*K(Dlist[k])]))
			k=k+1
		j=j+1
	T=V.union(Set([g.inverse() for g in V]))
	Kset=Kset.difference(T)
	perms=[Permutation(g) for g in T]
	perms=sorted(perms)
	sdreps.write(str(perms[0]))
	sdreps.write(str('\n'))
	cards=cards+[[perms[0],len(perms)]]
	i
	i=i+1
print("number of classes = ", i)
M=i
sdreps.close()

classlist = cards

##calculates partial traces for all equivalence classes (reps to be loaded in from file) for up to N=8 regions

N=4
K=SymmetricGroup(N)
Dlist=DihedralGroup(N)

#make a list of the irreps
reps=SymmetricGroupRepresentations(N,"seminormal").list()
L=len(reps)

#make a list of the irreps of s - firstly just of s_1
irrepss=[reps[k]((1,N)) for k in range(L)]

#make a list of the dimensions of the irreps
dims=[irrepss[i].nrows() for i in range(L)]

#finish calculating the irreps of s ##nb this gives 3N*s -- ie, need to divide e-values by 3N at the last step##
i=0
while i<L:
	j=1
	while j<N:
		irrepss[i]=irrepss[i]+reps[i]((j,j+1))
		j=j+1
	i=i+1

#make these matrices immutable 
i=0
while i<L:
	irrepss[i].set_immutable()
	i=i+1

save(irrepss,'irrepss'+str(N))
save(dims,'dims'+str(N))

#find the eigenvalues of the irreps as a sensible sorted list
Elist=[sorted(Set(irrepss[i].eigenvalues()).list()) for i in range(L)]

save(Elist,'Elist'+str(N))

#how many eigenvalues does each irrep have?
numEs=[len(Elist[k]) for k in range(L)]

#projections.... go!
proj=[[matrix.identity(dims[i]) for j in range(numEs[i])] for i in range(L)] ##this is the list skeleton, filled with identity matrices

i=0
while i<L:
	j=0
	while j<numEs[i]:
		k=0
		while k<numEs[i]:
			if k!=j:
				proj[i][j]=proj[i][j]*(irrepss[i]-CDF(Elist[i][k]))*(1/(CDF(Elist[i][j]-Elist[i][k])))
			k=k+1
		j=j+1
	print(i,'th rep projections done')
	i=i+1

save(proj,'proj'+str(N))




##we also need the irreps of d
irrepsD=[0 for i in range(L)]

i=0
while i<L:
	j=0
	while j<2*N:
		irrepsD[i]=irrepsD[i]+reps[i](K(Dlist[j]))
		j=j+1
	i=i+1

save(irrepsD,'irrepsD'+str(N))


##now calculate the partial traces
traces=[matrix(RDF,M,numEs[i]) for i in range(L)]
tracef=open('partial_traces_S'+str(N)+'.txt','w')
i=0
while i<L:
	reps[i]
	tracef.write(str(reps[i]))
	tracef.write(str('\n'))
	tracef.write(str("dimension ")+str(dims[i]))
	tracef.write(str('\n'))
	tracef.write(str("e-values ")+str(Elist[i]))
	tracef.write(str('\n'))
	tracef.write(str("partial-traces "))
	tracef.write(str('\n'))
	k=0
	while k<M:
		sigd=reps[i](K(classlist[k][0]))*irrepsD[i]
		j=0
		while j<len(Elist[i]):
			traces[i][k,j]=real((sigd*proj[i][j]).trace())
			j=j+1
		tracef.write(str(traces[i][k,:]))
		tracef.write(str('\n'))
		k=k+1
	print(i)
	i=i+1
tracef.close()

save(traces,'__traces_S'+str(N))
